
|Topic| Description|Author |
|--|--|--|
| Thread and Handler | Thread 관련 정리 | 남현웅

## **스레드**

프로세스 내에서 순차적으로 실행되는 실행흐름의 최소 단위를 말한다.
일반적으로 하나의 프로세스는 하나의 스레드를 가지고 작업을 수행한다.
여기서 멀티 스레드와 멀티 프로세스의 차이점을 인지하고 있어야 한다.

### 멀티 스레드 
-> 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것을 말한다.

### 멀티 프로세스
-> 여러개의 CPU 를 사용하여 여러 프로세스를 동시에 수행하는 것을 말한다.

어플리케이션이 실행되면, 안드로이드 시스템은 해당 어플리케이션의 main thread 를 생성한다.
이 Thread는 UI 위젯들을 그리는 역할을 수행하기 때문에 굉장히 중요하다.
main thread는 UI 를 그리고 상호작용하는 역할과 밀접한 관련이 있기 때문에 UI thread 라고도 불린다. 그러나, 특정 상황에서는 메인 쓰레드가 UI 쓰레드가 아닐 수도 있다.

동일한 프로세스 내에서 실행되는 모든 컴포넌트들은 UI thread에서 인스턴스화 되며, 각 컴포넌트들에 대한 호출은 UI thread에서 실행된다. 결과적으로, 시스템 콜백에 응답하는 메소드들은 항상 프로세스의 UI thread에서 실행되는 것이다.

그러나, 만약 모든 일들이 UI thread에서만 처리되는 경우, 네트워크 접근이나 데이터베이스를 쿼리해오는 긴 작업을 수행하게 되면 모든 UI 가 블록되는 현상이 발생한다. UI thread가 블록되면, 그리기 이벤트와 같은 모든 이벤트들이 실행되지 않는다. 그렇게 되면 사용자 입장에서는 어플리케이션이 죽은 것처럼 보이고, 심지어 UI thread가 5초 이상 블록되면 ANR "어플리케이션이 응답하지 않음" 다이얼로그가 표시되게 된다.

안드로이드 어플리케이션은 UI 쓰레드가 아닌 다른 쓰레드에서는 UI 를 건드릴 수가 없다. 그래서 UI 쓰레드가 블록되지 않도록 하는 것이 중요하다.

### 올바른 스레드 구조
![enter image description here](https://t1.daumcdn.net/cfile/tistory/22292D48577CA81213)

```
fun onClick(v: View) { 
	Thread(Runnable { 
		// a potentially time consuming task  
		val bitmap = processBitMap("image.png") 
		imageView.post { imageView.setImageBitmap(bitmap) } 	
	}).start() }
```

이렇게, implementation 하면 ImageView 가 UI 쓰레드에서 조작되면서, 백그라운드 작업이 별도의 쓰레드에서 작동된다. 그러나, 작업이 복잡해지면 이런식의 코드는 관리가 어렵고 복잡해진다. 이것보다 복잡한 상호작용을 구현하고 싶다면, worker thread 에서 Handler 를 사용하면 된다.

### 안드로이드에서 Thread 를 사용하는 이유

안드로이드에서 쓰레드는 자바에서의 쓰레드와 비슷하다. 서브 쓰레드를 이용하면 메인 쓰레드에서 진행되는 코드흐름 이외에 다른 작업을 동시에 수행할 수 있다. 그러나, 안드로이드에서 UI 를 업데이트는 main Thread , 즉 UI 쓰레드에서만 진행되어야 한다. UI 를 메인 쓰레드 이외의 다른 쓰레드에서 처리하기 위해서 Handler 라는 개념이 나왔다. Handler 는 서브스레드에서 작업한 것들을 메시지 큐에 담아서 UI 쓰레드에 선입선출 방식으로 전달해주는 역할을 수행한다.
